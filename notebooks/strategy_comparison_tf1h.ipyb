{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ac57e15a",
   "metadata": {},
   "source": [
    "# Perbandingan Strategi EMA112 vs VWAP (TF 1H)\n",
    "\n",
    "Notebook ini menjalankan dua strategi rule-based pada data OHLCV ETHUSDT 1 jam.\n",
    "Fokusnya adalah membandingkan strategi trend-following EMA112 dengan strategi mean-reversion VWAP\n",
    "sehingga kita bisa cepat melihat karakteristik masing-masing pendekatan.\n",
    "\n",
    "Detail penting:\n",
    "- Dataset: `data/BINANCE_ETHUSDT.P, 60.csv` (Binance perpetual, timeframe 1H).\n",
    "- Output backtest: `outputs/strategy_comparison_tf1h/` serta ekspor Excel `outputs/result-test/strategy_comparison_tf1h.xlsx`.\n",
    "- Strategi yang diuji: EMA112 (trend) vs VWAP (mean-reversion) plus opsi sinyal ML eksternal."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5da44165",
   "metadata": {},
   "outputs": [],
   "source": [
    "from __future__ import annotations\n",
    "\n",
    "import sys\n",
    "from pathlib import Path\n",
    "from typing import Mapping\n",
    "\n",
    "import matplotlib\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from IPython.display import display\n",
    "\n",
    "if not hasattr(matplotlib.rcParams, '_get'):\n",
    "    def _rcparams_get(key, default=None):\n",
    "        return matplotlib.rcParams.get(key, default)\n",
    "    matplotlib.rcParams._get = _rcparams_get\n",
    "\n",
    "\n",
    "\n",
    "def locate_project_root() -> Path:\n",
    "    \"\"\"Temukan root repository agar path relatif bekerja di mana saja.\"\"\"\n",
    "\n",
    "    current = Path.cwd().resolve()\n",
    "    for candidate in (current, *current.parents):\n",
    "        if (candidate / 'src').exists() and (candidate / 'data').exists():\n",
    "            return candidate\n",
    "    raise RuntimeError(\"Folder proyek tidak ditemukan dari direktori kerja saat ini.\")\n",
    "\n",
    "\n",
    "PROJECT_ROOT = locate_project_root()\n",
    "if str(PROJECT_ROOT) not in sys.path:\n",
    "    sys.path.insert(0, str(PROJECT_ROOT))\n",
    "\n",
    "from src.pipelines import (  # noqa: E402  # isort: skip\n",
    "    IndicatorConfig,\n",
    "    SingleAssetPipelineConfig,\n",
    "    run_single_asset_pipeline,\n",
    "    save_backtest_outputs,\n",
    ")\n",
    "from src.performance.metrics import summarise_bar_returns  # noqa: E402  # isort: skip\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5fd2a86e",
   "metadata": {},
   "source": [
    "### Konfigurasi strategi\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c3ca72e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "DATA_PATH = PROJECT_ROOT / 'data' / 'BINANCE_ETHUSDT.P, 60.csv'\n",
    "OUTPUT_DIR = PROJECT_ROOT / 'outputs' / 'strategy_comparison_tf1h'\n",
    "OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n",
    "\n",
    "ML_PREDICTION_PATHS = {\n",
    "    'ml_lightgbm': PROJECT_ROOT / 'outputs' / 'predictions' / 'lightgbm_ml_baseline_predictions.csv',\n",
    "    'ml_logreg': PROJECT_ROOT / 'outputs' / 'predictions' / 'ml_logreg_baseline_predictions.csv',\n",
    "    'ml_linreg': PROJECT_ROOT / 'outputs' / 'predictions' / 'ml_linreg_baseline_predictions.csv',\n",
    "}\n",
    "ML_DISPLAY_LABELS = {\n",
    "    'ml_lightgbm': 'ML LightGBM',\n",
    "    'ml_logreg': 'ML Logistic Regression',\n",
    "    'ml_linreg': 'ML Linear Regression',\n",
    "}\n",
    "SECONDS_IN_YEAR = 365 * 24 * 60 * 60\n",
    "BARS_PER_DAY = 24.0\n",
    "BARS_PER_YEAR = BARS_PER_DAY * 365.0\n",
    "\n",
    "STRATEGY_SETUPS = {\n",
    "    'ema112': {\n",
    "        'strategy_name': 'ema112',\n",
    "        'strategy_kwargs': {\n",
    "            'ema_length': 112,\n",
    "            'price_column': 'close',\n",
    "        },\n",
    "        'price_column': 'close',\n",
    "        'horizon_bars': 4000,\n",
    "        'indicators': [\n",
    "            {\n",
    "                'name': 'ema',\n",
    "                'source_column': 'close',\n",
    "                'target_column': 'ema_reference',\n",
    "                'params': {'span': 112},\n",
    "            }\n",
    "        ],\n",
    "        'output_prefix': 'ema112_hourly',\n",
    "        'save_outputs': True,\n",
    "    },\n",
    "    'vwap': {\n",
    "        'strategy_name': 'vwap',\n",
    "        'strategy_kwargs': {\n",
    "            'rsi_length': 14,\n",
    "            'rsi_overbought': 70,\n",
    "            'rsi_oversold': 30,\n",
    "            'atr_length': 14,\n",
    "            'atr_stop_multiplier': 1.5,\n",
    "            'session_frequency': '1D',\n",
    "        },\n",
    "        'price_column': 'close',\n",
    "        'horizon_bars': 4000,\n",
    "        'indicators': [],\n",
    "        'output_prefix': 'vwap_hourly',\n",
    "        'save_outputs': True,\n",
    "    },\n",
    "}\n",
    "\n",
    "\n",
    "def estimate_years(index: pd.DatetimeIndex) -> float:\n",
    "    if not isinstance(index, pd.DatetimeIndex) or len(index) < 2:\n",
    "        return float('nan')\n",
    "    elapsed = (index[-1] - index[0]).total_seconds()\n",
    "    return elapsed / SECONDS_IN_YEAR if elapsed > 0 else float('nan')\n",
    "\n",
    "\n",
    "def turnover_from_trades(trades: pd.DataFrame, index: pd.DatetimeIndex) -> float:\n",
    "    years = estimate_years(index)\n",
    "    if trades is None or trades.empty or not years or years <= 0:\n",
    "        return float('nan')\n",
    "    return float(len(trades) / years)\n",
    "\n",
    "\n",
    "def turnover_from_positions(positions: pd.Series) -> float:\n",
    "    if positions is None or positions.empty:\n",
    "        return float('nan')\n",
    "    years = estimate_years(positions.index)\n",
    "    if not years or years <= 0:\n",
    "        return float('nan')\n",
    "    changes = positions.diff().abs().fillna(0.0)\n",
    "    return float((changes.sum() / 2.0) / years)\n",
    "\n",
    "\n",
    "def average_hold_bars(trades: pd.DataFrame | None = None, positions: pd.Series | None = None) -> float:\n",
    "    if trades is not None and not trades.empty and 'bars_held' in trades.columns:\n",
    "        return float(trades['bars_held'].mean())\n",
    "    if positions is None or positions.empty:\n",
    "        return float('nan')\n",
    "    mask = positions != 0\n",
    "    if not mask.any():\n",
    "        return float('nan')\n",
    "    groups = mask.ne(mask.shift()).cumsum()\n",
    "    lengths = mask.groupby(groups).sum()\n",
    "    lengths = lengths[lengths > 0]\n",
    "    if lengths.empty:\n",
    "        return float('nan')\n",
    "    return float(lengths.mean())\n",
    "\n",
    "\n",
    "def build_pipeline_config(setup: Mapping[str, object]) -> SingleAssetPipelineConfig:\n",
    "    indicators = tuple(IndicatorConfig(**item) for item in setup.get('indicators', []))\n",
    "    data_path = Path(setup.get('data_path', DATA_PATH))\n",
    "    if not data_path.exists():\n",
    "        raise FileNotFoundError(f\"File data {data_path} tidak ditemukan.\")\n",
    "    return SingleAssetPipelineConfig(\n",
    "        data_path=str(data_path),\n",
    "        strategy_name=setup['strategy_name'],\n",
    "        strategy_kwargs=setup.get('strategy_kwargs', {}),\n",
    "        horizon_bars=setup.get('horizon_bars'),\n",
    "        indicators=indicators,\n",
    "        price_column=setup.get('price_column', 'close'),\n",
    "    )\n",
    "\n",
    "\n",
    "def infer_prediction_horizon(index: pd.DatetimeIndex | None) -> pd.Timedelta | None:\n",
    "    if index is None or not isinstance(index, pd.DatetimeIndex) or len(index) < 2:\n",
    "        return None\n",
    "    deltas = index.to_series().diff().dropna()\n",
    "    if deltas.empty:\n",
    "        return None\n",
    "    median_delta = deltas.median()\n",
    "    return median_delta if pd.notna(median_delta) else None\n",
    "\n",
    "\n",
    "def _max_streak(mask: pd.Series) -> int:\n",
    "    streak = 0\n",
    "    max_streak = 0\n",
    "    for flag in mask.astype(bool):\n",
    "        if flag:\n",
    "            streak += 1\n",
    "            max_streak = max(max_streak, streak)\n",
    "        else:\n",
    "            streak = 0\n",
    "    return max_streak\n",
    "\n",
    "\n",
    "def summarise_simple_trades(trades: pd.DataFrame, positions: pd.Series | None) -> dict:\n",
    "    summary: dict[str, float] = {'total_trades': int(len(trades))}\n",
    "    total_bars = int(len(positions)) if positions is not None else 0\n",
    "    if total_bars > 0 and positions is not None:\n",
    "        in_market = int((positions != 0).sum())\n",
    "        long_bars = int((positions > 0).sum())\n",
    "        short_bars = int((positions < 0).sum())\n",
    "        flat_bars = total_bars - in_market\n",
    "        summary.update(\n",
    "            {\n",
    "                'bars_in_market': float(in_market),\n",
    "                'bars_flat': float(flat_bars),\n",
    "                'time_in_market_pct': float(in_market / total_bars) if total_bars else float('nan'),\n",
    "                'flat_time_pct': float(flat_bars / total_bars) if total_bars else float('nan'),\n",
    "                'long_exposure_pct': float(long_bars / total_bars) if total_bars else float('nan'),\n",
    "                'short_exposure_pct': float(short_bars / total_bars) if total_bars else float('nan'),\n",
    "                'avg_position': float(positions.mean()),\n",
    "                'avg_abs_position': float(positions.abs().mean()),\n",
    "            }\n",
    "        )\n",
    "    else:\n",
    "        summary.update(\n",
    "            {\n",
    "                'bars_in_market': float('nan'),\n",
    "                'bars_flat': float('nan'),\n",
    "                'time_in_market_pct': float('nan'),\n",
    "                'flat_time_pct': float('nan'),\n",
    "                'long_exposure_pct': float('nan'),\n",
    "                'short_exposure_pct': float('nan'),\n",
    "                'avg_position': float('nan'),\n",
    "                'avg_abs_position': float('nan'),\n",
    "            }\n",
    "        )\n",
    "\n",
    "    if trades.empty:\n",
    "        summary.update(\n",
    "            {\n",
    "                'long_trades': 0,\n",
    "                'short_trades': 0,\n",
    "                'winning_trades': 0,\n",
    "                'losing_trades': 0,\n",
    "                'breakeven_trades': 0,\n",
    "                'win_rate': float('nan'),\n",
    "                'loss_rate': float('nan'),\n",
    "                'breakeven_rate': float('nan'),\n",
    "                'avg_pnl_pct': float('nan'),\n",
    "                'avg_pnl_currency': float('nan'),\n",
    "                'median_pnl_pct': float('nan'),\n",
    "                'net_profit_pct': float('nan'),\n",
    "                'net_profit_currency': float('nan'),\n",
    "                'gross_profit_pct': float('nan'),\n",
    "                'gross_loss_pct': float('nan'),\n",
    "                'gross_profit_currency': float('nan'),\n",
    "                'gross_loss_currency': float('nan'),\n",
    "                'profit_factor_pct': float('nan'),\n",
    "                'profit_factor_currency': float('nan'),\n",
    "                'avg_win_pct': float('nan'),\n",
    "                'avg_loss_pct': float('nan'),\n",
    "                'avg_win_currency': float('nan'),\n",
    "                'avg_loss_currency': float('nan'),\n",
    "                'avg_bars': float('nan'),\n",
    "                'median_bars': float('nan'),\n",
    "                'avg_bars_winning': float('nan'),\n",
    "                'avg_bars_losing': float('nan'),\n",
    "                'max_consecutive_wins': 0.0,\n",
    "                'max_consecutive_losses': 0.0,\n",
    "                'long_short_ratio': float('nan'),\n",
    "                'best_trade_pct': float('nan'),\n",
    "                'worst_trade_pct': float('nan'),\n",
    "                'best_trade_currency': float('nan'),\n",
    "                'worst_trade_currency': float('nan'),\n",
    "            }\n",
    "        )\n",
    "        return summary\n",
    "\n",
    "    pnl_pct = trades['pnl_pct'].astype(float)\n",
    "    pnl_currency = trades['pnl_currency'].astype(float)\n",
    "    bars_held = trades['bars_held'].astype(float)\n",
    "    long_mask = trades['direction'] == 'Long'\n",
    "    short_mask = trades['direction'] == 'Short'\n",
    "    winning_mask = pnl_pct > 0\n",
    "    losing_mask = pnl_pct < 0\n",
    "    breakeven_mask = ~(winning_mask | losing_mask)\n",
    "\n",
    "    wins_pct = pnl_pct[winning_mask]\n",
    "    losses_pct = pnl_pct[losing_mask]\n",
    "    wins_cur = pnl_currency[winning_mask]\n",
    "    losses_cur = pnl_currency[losing_mask]\n",
    "\n",
    "    gross_profit_pct = float(wins_pct.sum()) if winning_mask.any() else 0.0\n",
    "    gross_loss_pct = float(-losses_pct.sum()) if losing_mask.any() else 0.0\n",
    "    gross_profit_currency = float(wins_cur.sum()) if winning_mask.any() else 0.0\n",
    "    gross_loss_currency = float(-losses_cur.sum()) if losing_mask.any() else 0.0\n",
    "\n",
    "    summary.update(\n",
    "        {\n",
    "            'long_trades': int(long_mask.sum()),\n",
    "            'short_trades': int(short_mask.sum()),\n",
    "            'winning_trades': int(winning_mask.sum()),\n",
    "            'losing_trades': int(losing_mask.sum()),\n",
    "            'breakeven_trades': int(breakeven_mask.sum()),\n",
    "            'win_rate': float(winning_mask.mean()),\n",
    "            'loss_rate': float(losing_mask.mean()),\n",
    "            'breakeven_rate': float(breakeven_mask.mean()),\n",
    "            'avg_pnl_pct': float(pnl_pct.mean()),\n",
    "            'avg_pnl_currency': float(pnl_currency.mean()),\n",
    "            'median_pnl_pct': float(pnl_pct.median()),\n",
    "            'net_profit_pct': float(pnl_pct.sum()),\n",
    "            'net_profit_currency': float(pnl_currency.sum()),\n",
    "            'gross_profit_pct': gross_profit_pct,\n",
    "            'gross_loss_pct': gross_loss_pct,\n",
    "            'gross_profit_currency': gross_profit_currency,\n",
    "            'gross_loss_currency': gross_loss_currency,\n",
    "            'profit_factor_pct': gross_profit_pct / gross_loss_pct if gross_loss_pct else float('nan'),\n",
    "            'profit_factor_currency': gross_profit_currency / gross_loss_currency if gross_loss_currency else float('nan'),\n",
    "            'avg_win_pct': float(wins_pct.mean()) if winning_mask.any() else float('nan'),\n",
    "            'avg_loss_pct': float(losses_pct.mean()) if losing_mask.any() else float('nan'),\n",
    "            'avg_win_currency': float(wins_cur.mean()) if winning_mask.any() else float('nan'),\n",
    "            'avg_loss_currency': float(losses_cur.mean()) if losing_mask.any() else float('nan'),\n",
    "            'avg_bars': float(bars_held.mean()),\n",
    "            'median_bars': float(bars_held.median()),\n",
    "            'avg_bars_winning': float(bars_held[winning_mask].mean()) if winning_mask.any() else float('nan'),\n",
    "            'avg_bars_losing': float(bars_held[losing_mask].mean()) if losing_mask.any() else float('nan'),\n",
    "            'max_consecutive_wins': float(_max_streak(winning_mask)),\n",
    "            'max_consecutive_losses': float(_max_streak(losing_mask)),\n",
    "            'long_short_ratio': float(long_mask.sum() / short_mask.sum()) if short_mask.sum() else float('nan'),\n",
    "            'best_trade_pct': float(pnl_pct.max()),\n",
    "            'worst_trade_pct': float(pnl_pct.min()),\n",
    "            'best_trade_currency': float(pnl_currency.max()),\n",
    "            'worst_trade_currency': float(pnl_currency.min()),\n",
    "        }\n",
    "    )\n",
    "    return summary\n",
    "\n",
    "\n",
    "def build_ml_trade_frame(predictions: pd.DataFrame) -> pd.DataFrame:\n",
    "    if predictions is None or predictions.empty:\n",
    "        return pd.DataFrame(\n",
    "            columns=[\n",
    "                'trade_id',\n",
    "                'direction',\n",
    "                'entry_time',\n",
    "                'exit_time',\n",
    "                'bars_held',\n",
    "                'position',\n",
    "                'probability',\n",
    "                'signal',\n",
    "                'future_return',\n",
    "                'pnl_pct',\n",
    "                'pnl_currency',\n",
    "                'side_pnl',\n",
    "                'mae',\n",
    "                'mfe',\n",
    "            ]\n",
    "        )\n",
    "    trades = predictions.copy()\n",
    "    required = {'position', 'pnl'}\n",
    "    missing = required.difference(trades.columns)\n",
    "    if missing:\n",
    "        raise KeyError(f\"Kolom wajib hilang dari prediksi ML: {sorted(missing)}\")\n",
    "    trades = trades[trades['position'] != 0].copy()\n",
    "    trades = trades.sort_index()\n",
    "    trades['trade_id'] = np.arange(1, len(trades) + 1)\n",
    "    trades['direction'] = np.where(trades['position'] > 0, 'Long', 'Short')\n",
    "    trades['pnl_pct'] = trades['pnl'].astype(float)\n",
    "    trades['pnl_currency'] = trades['pnl_pct']\n",
    "    trades['side_pnl'] = np.where(trades['position'] > 0, trades['pnl_pct'], -trades['pnl_pct'])\n",
    "    trades['bars_held'] = 1\n",
    "    trades['mae'] = np.where(trades['pnl_pct'] < 0, trades['pnl_pct'], 0.0)\n",
    "    trades['mfe'] = np.where(trades['pnl_pct'] > 0, trades['pnl_pct'], 0.0)\n",
    "    horizon = infer_prediction_horizon(predictions.index)\n",
    "    trades['entry_time'] = trades.index\n",
    "    trades['exit_time'] = trades['entry_time'] + horizon if horizon is not None else pd.NaT\n",
    "    ordered = [\n",
    "        'trade_id',\n",
    "        'direction',\n",
    "        'entry_time',\n",
    "        'exit_time',\n",
    "        'bars_held',\n",
    "        'position',\n",
    "        'probability',\n",
    "        'signal',\n",
    "        'future_return',\n",
    "        'pnl_pct',\n",
    "        'pnl_currency',\n",
    "        'side_pnl',\n",
    "        'mae',\n",
    "        'mfe',\n",
    "    ]\n",
    "    for column in ordered:\n",
    "        if column not in trades.columns:\n",
    "            trades[column] = np.nan\n",
    "    return trades[ordered + [col for col in trades.columns if col not in ordered]]\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "11d8ed25",
   "metadata": {},
   "source": [
    "### Jalankan backtest EMA112 & VWAP\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c945268b",
   "metadata": {},
   "outputs": [],
   "source": [
    "results = {}\n",
    "\n",
    "for label, setup in STRATEGY_SETUPS.items():\n",
    "    print(f\"Menjalankan strategi {label}...\")\n",
    "    pipeline_cfg = build_pipeline_config(setup)\n",
    "    outputs = run_single_asset_pipeline(pipeline_cfg)\n",
    "    results[label] = outputs\n",
    "\n",
    "    metrics_df = pd.Series(outputs.metrics, name='value').to_frame()\n",
    "    trade_summary_df = pd.Series(outputs.trade_summary, name='value').to_frame()\n",
    "\n",
    "    print(f\"Ringkasan metrics ({label}):\")\n",
    "    display(metrics_df.style.format({'value': '{:.4f}'}))\n",
    "\n",
    "    print(f\"Ringkasan trade ({label}):\")\n",
    "    display(trade_summary_df.style.format({'value': '{:.4f}'}))\n",
    "\n",
    "    if setup.get('save_outputs'):\n",
    "        prefix = setup.get('output_prefix', label)\n",
    "        artifacts = save_backtest_outputs(outputs, OUTPUT_DIR, prefix=prefix)\n",
    "        print('Artifacts tersimpan:')\n",
    "        for name, artifact_path in artifacts.items():\n",
    "            print(f\"  - {name}: {artifact_path}\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79725a22",
   "metadata": {},
   "source": [
    "### Bandingkan kinerja kedua strategi\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cd5e81b4",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "ml_predictions_map: dict[str, pd.DataFrame] = {}\n",
    "ml_equity_map: dict[str, pd.DataFrame] = {}\n",
    "ml_trades_map: dict[str, pd.DataFrame] = {}\n",
    "ml_trade_summary_map: dict[str, dict] = {}\n",
    "ml_metrics_map: dict[str, dict] = {}\n",
    "for label, path in ML_PREDICTION_PATHS.items():\n",
    "    if not path.exists():\n",
    "        print(f\"File prediksi {path} tidak ditemukan untuk {label}, melewati.\")\n",
    "        continue\n",
    "    frame = pd.read_csv(path, parse_dates=['time']).set_index('time')\n",
    "    if 'position' not in frame.columns:\n",
    "        signal = frame.get('signal', pd.Series(0.0, index=frame.index))\n",
    "        frame['position'] = np.sign(signal.fillna(0.0))\n",
    "    if 'pnl' not in frame.columns:\n",
    "        future_ret = frame.get('future_return', pd.Series(0.0, index=frame.index))\n",
    "        frame['pnl'] = frame['position'].fillna(0.0) * future_ret.fillna(0.0)\n",
    "    ml_predictions_map[label] = frame\n",
    "\n",
    "if not results and not ml_predictions_map:\n",
    "    raise RuntimeError('Belum ada hasil backtest untuk dibandingkan.')\n",
    "\n",
    "label_map = {'ema112': 'EMA112', 'vwap': 'VWAP'}\n",
    "comparison_records: list[dict[str, object]] = []\n",
    "overview_rows: list[dict[str, object]] = []\n",
    "for label, output in results.items():\n",
    "    strategy_returns = output.results['strategy_return'].fillna(0.0)\n",
    "    stats = summarise_bar_returns(strategy_returns, bars_per_year=BARS_PER_YEAR)\n",
    "    record = {'strategy': label_map.get(label.lower(), label.upper())}\n",
    "    record.update(stats)\n",
    "    comparison_records.append(record)\n",
    "    overview_rows.append(\n",
    "        {\n",
    "            'strategy': label_map.get(label.lower(), label.upper()),\n",
    "            'total_return': stats['total_return'],\n",
    "            'cagr': stats['cagr'],\n",
    "            'annualised_vol': stats['annualised_vol'],\n",
    "            'sharpe_ratio': stats['sharpe_ratio'],\n",
    "            'max_drawdown': stats['max_drawdown'],\n",
    "            'time_in_market_pct': output.trade_summary.get('time_in_market_pct'),\n",
    "        }\n",
    "    )\n",
    "\n",
    "exposure_payload = {}\n",
    "for ml_label, ml_predictions in ml_predictions_map.items():\n",
    "    ml_returns = ml_predictions['pnl'].fillna(0.0)\n",
    "    ml_stats = summarise_bar_returns(ml_returns, bars_per_year=BARS_PER_YEAR)\n",
    "    ml_metrics_map[ml_label] = ml_stats\n",
    "    strategy_label = ML_DISPLAY_LABELS.get(ml_label, ml_label.upper())\n",
    "    comparison_records.append({'strategy': strategy_label, **ml_stats})\n",
    "    ml_positions = ml_predictions.get('position', pd.Series(index=ml_predictions.index, dtype=float)).fillna(0.0)\n",
    "    ml_equity_map[ml_label] = pd.DataFrame(\n",
    "        {\n",
    "            'position': ml_positions,\n",
    "            'future_return': ml_predictions.get('future_return'),\n",
    "            'pnl': ml_predictions['pnl'],\n",
    "            'equity_curve': (1.0 + ml_predictions['pnl'].fillna(0.0)).cumprod(),\n",
    "        },\n",
    "        index=ml_predictions.index,\n",
    "    )\n",
    "    trades = build_ml_trade_frame(ml_predictions)\n",
    "    ml_trades_map[ml_label] = trades\n",
    "    trade_summary = summarise_simple_trades(trades, ml_positions) if trades is not None else {}\n",
    "    ml_trade_summary_map[ml_label] = trade_summary\n",
    "    overview_rows.append(\n",
    "        {\n",
    "            'strategy': strategy_label,\n",
    "            'total_return': ml_stats.get('total_return'),\n",
    "            'cagr': ml_stats.get('cagr'),\n",
    "            'annualised_vol': ml_stats.get('annualised_vol'),\n",
    "            'sharpe_ratio': ml_stats.get('sharpe_ratio'),\n",
    "            'max_drawdown': ml_stats.get('max_drawdown'),\n",
    "            'time_in_market_pct': trade_summary.get('time_in_market_pct') if trade_summary else float('nan'),\n",
    "        }\n",
    "    )\n",
    "    if trade_summary:\n",
    "        print(f\"Ringkasan trade ({strategy_label}):\")\n",
    "        display(pd.Series(trade_summary, name='value').to_frame().style.format({'value': '{:.4f}'}))\n",
    "    exposure_payload[strategy_label] = {\n",
    "        'time_in_market_pct': float((ml_positions != 0).mean()),\n",
    "        'avg_position': float(ml_positions.mean()),\n",
    "        'avg_abs_position': float(ml_positions.abs().mean()),\n",
    "        'total_trades': trade_summary.get('total_trades') if trade_summary else float('nan'),\n",
    "        'win_rate': trade_summary.get('win_rate') if trade_summary else float('nan'),\n",
    "        'turnover_per_year': turnover_from_positions(ml_positions),\n",
    "        'avg_hold_bars': average_hold_bars(trades=trades, positions=ml_positions),\n",
    "    }\n",
    "\n",
    "comparison = (\n",
    "    pd.DataFrame(comparison_records)\n",
    "    .set_index('strategy')\n",
    "    .sort_index()\n",
    ")\n",
    "\n",
    "print('Ringkasan metrics head-to-head:')\n",
    "display(comparison)\n",
    "\n",
    "overview_columns = [\n",
    "    'strategy',\n",
    "    'total_return',\n",
    "    'cagr',\n",
    "    'annualised_vol',\n",
    "    'sharpe_ratio',\n",
    "    'max_drawdown',\n",
    "    'time_in_market_pct',\n",
    "]\n",
    "strategy_overview = pd.DataFrame(overview_rows, columns=overview_columns).set_index('strategy')\n",
    "desired_order = list(ML_DISPLAY_LABELS.values()) + ['EMA112', 'VWAP']\n",
    "strategy_overview = strategy_overview.reindex(\n",
    "    desired_order + [idx for idx in strategy_overview.index if idx not in desired_order]\n",
    ")\n",
    "\n",
    "print('Strategi utama (ML vs EMA112 vs VWAP):')\n",
    "display(strategy_overview)\n",
    "\n",
    "for ml_label, ml_metrics in ml_metrics_map.items():\n",
    "    display_name = ML_DISPLAY_LABELS.get(ml_label, ml_label.upper())\n",
    "    print(f'Ringkasan metrics ({display_name}):')\n",
    "    display(pd.Series(ml_metrics, name='value').to_frame().style.format({'value': '{:.4f}'}))\n",
    "\n",
    "for label, output in results.items():\n",
    "    summary = output.trade_summary\n",
    "    exposure_payload[label_map.get(label.lower(), label.upper())] = {\n",
    "        'time_in_market_pct': summary.get('time_in_market_pct'),\n",
    "        'avg_position': summary.get('avg_position'),\n",
    "        'avg_abs_position': summary.get('avg_abs_position'),\n",
    "        'total_trades': summary.get('total_trades'),\n",
    "        'win_rate': summary.get('win_rate'),\n",
    "        'turnover_per_year': turnover_from_trades(output.trades, output.results.index),\n",
    "        'avg_hold_bars': average_hold_bars(trades=output.trades),\n",
    "    }\n",
    "\n",
    "exposure = pd.DataFrame(exposure_payload).transpose()\n",
    "print('Eksposur & jumlah trade:')\n",
    "display(exposure)\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e1258efc",
   "metadata": {},
   "source": [
    "### Cuplikan trade terbaru\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "54e19c57",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for label, output in results.items():\n",
    "    print(f\"Trade terbaru untuk {label}:\")\n",
    "    tail_trades = output.trades.tail().reset_index(drop=True)\n",
    "    display(tail_trades)\n",
    "\n",
    "if ml_trades_map:\n",
    "    for ml_label, ml_trades in ml_trades_map.items():\n",
    "        if ml_trades is None or ml_trades.empty:\n",
    "            print(f\"Prediksi {ml_label} belum menghasilkan trade untuk ditampilkan.\")\n",
    "            continue\n",
    "        display_name = ML_DISPLAY_LABELS.get(ml_label, ml_label)\n",
    "        print(f\"Trade terbaru untuk {display_name}:\")\n",
    "        display(ml_trades.tail().reset_index(drop=True))\n",
    "else:\n",
    "    print(\"Prediksi ML belum menghasilkan trade untuk ditampilkan.\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "932f7faa",
   "metadata": {},
   "source": [
    "### Analisis tambahan: distribusi PnL & MAE/MFE\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6e9916a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "plot_payload = {label: output.trades for label, output in results.items()}\n",
    "for ml_label, trades in ml_trades_map.items():\n",
    "    if trades is not None:\n",
    "        plot_payload[ML_DISPLAY_LABELS.get(ml_label, ml_label)] = trades\n",
    "\n",
    "for label, trades in plot_payload.items():\n",
    "    if trades is None or trades.empty:\n",
    "        print(f'Tidak ada data trade untuk {label}.')\n",
    "        continue\n",
    "    pnl = trades.get('pnl_pct')\n",
    "    if pnl is None:\n",
    "        print(f'Tidak ada kolom pnl_pct untuk {label}.')\n",
    "        continue\n",
    "    fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
    "    axes[0].hist(pnl.dropna(), bins=30, color='#1f77b4', alpha=0.8)\n",
    "    axes[0].set_title(f'Distribusi PnL % - {label}')\n",
    "    axes[0].set_xlabel('pnl_pct')\n",
    "    axes[0].set_ylabel('Frekuensi')\n",
    "\n",
    "    mae = trades.get('mae')\n",
    "    mfe = trades.get('mfe')\n",
    "    mae_mfe = None\n",
    "    if mae is not None and mfe is not None:\n",
    "        mae_mfe = pd.DataFrame({'mae': mae, 'mfe': mfe}).dropna()\n",
    "    if mae_mfe is not None and not mae_mfe.empty:\n",
    "        axes[1].scatter(mae_mfe['mae'], mae_mfe['mfe'], alpha=0.6, color='#ff7f0e', edgecolor='none')\n",
    "    else:\n",
    "        axes[1].text(0.5, 0.5, 'Tidak ada data MAE/MFE', transform=axes[1].transAxes, ha='center')\n",
    "    axes[1].set_title(f'MAE vs MFE - {label}')\n",
    "    axes[1].set_xlabel('MAE')\n",
    "    axes[1].set_ylabel('MFE')\n",
    "    axes[1].axhline(0, color='grey', linewidth=0.8, linestyle='--')\n",
    "    axes[1].axvline(0, color='grey', linewidth=0.8, linestyle='--')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "56398b8e",
   "metadata": {},
   "outputs": [],
   "source": [
    "import importlib.util\n",
    "from pathlib import Path\n",
    "import pandas as pd\n",
    "from datetime import datetime, timezone\n",
    "try:\n",
    "    PROJECT_ROOT\n",
    "except NameError:  # pragma: no cover - notebook convenience\n",
    "    PROJECT_ROOT = Path.cwd()\n",
    "\n",
    "\n",
    "\n",
    "def export_tables_to_excel(tables, path: Path) -> Path:\n",
    "    def strip_timezone_from_value(value):\n",
    "        if value is pd.NaT:\n",
    "            return value\n",
    "        if isinstance(value, pd.Timestamp):\n",
    "            if value.tz is not None:\n",
    "                return value.tz_convert(\"UTC\").tz_localize(None)\n",
    "            return value\n",
    "        if isinstance(value, datetime):\n",
    "            if value.tzinfo is not None:\n",
    "                return value.astimezone(timezone.utc).replace(tzinfo=None)\n",
    "            return value\n",
    "        return value\n",
    "\n",
    "    def strip_timezone_from_axis(axis):\n",
    "        if isinstance(axis, pd.MultiIndex):\n",
    "            new_levels = [strip_timezone_from_axis(level) for level in axis.levels]\n",
    "            return axis.set_levels(new_levels)\n",
    "        if isinstance(axis, pd.DatetimeIndex) and axis.tz is not None:\n",
    "            return axis.tz_convert(\"UTC\").tz_localize(None)\n",
    "        if getattr(axis, \"dtype\", None) == object:\n",
    "            return pd.Index([strip_timezone_from_value(val) for val in axis], name=axis.name)\n",
    "        return axis\n",
    "\n",
    "    def make_excel_safe(frame: pd.DataFrame) -> pd.DataFrame:\n",
    "        frame = frame.copy()\n",
    "        frame.index = strip_timezone_from_axis(frame.index)\n",
    "        frame.columns = strip_timezone_from_axis(frame.columns)\n",
    "        for column in frame.columns:\n",
    "            series = frame[column]\n",
    "            if isinstance(series.dtype, pd.DatetimeTZDtype):\n",
    "                frame[column] = series.dt.tz_convert(\"UTC\").dt.tz_localize(None)\n",
    "            elif series.dtype == object:\n",
    "                frame[column] = series.map(strip_timezone_from_value)\n",
    "        return frame\n",
    "\n",
    "    serialisable = []\n",
    "    for sheet_name, table in tables.items():\n",
    "        if table is None:\n",
    "            continue\n",
    "        if isinstance(table, pd.Series):\n",
    "            frame = table.to_frame()\n",
    "        elif isinstance(table, pd.DataFrame):\n",
    "            frame = table.copy()\n",
    "        elif isinstance(table, dict):\n",
    "            frame = pd.DataFrame([table])\n",
    "        else:\n",
    "            frame = pd.DataFrame(table)\n",
    "        frame = make_excel_safe(frame)\n",
    "        serialisable.append((sheet_name, frame))\n",
    "\n",
    "    if not serialisable:\n",
    "        raise ValueError(\"Tidak ada tabel yang bisa diekspor.\")\n",
    "\n",
    "    path.parent.mkdir(parents=True, exist_ok=True)\n",
    "\n",
    "    def pick_engine() -> str:\n",
    "        for candidate in (\"openpyxl\", \"xlsxwriter\"):\n",
    "            if importlib.util.find_spec(candidate):\n",
    "                return candidate\n",
    "        raise ModuleNotFoundError(\n",
    "            \"Untuk ekspor Excel diperlukan paket 'openpyxl' atau 'xlsxwriter'.\"\n",
    "        )\n",
    "\n",
    "    def normalise_sheet_name(name: str, existing) -> str:\n",
    "        safe = (name or \"Sheet\").strip() or \"Sheet\"\n",
    "        safe = safe[:31]\n",
    "        counter = 1\n",
    "        candidate = safe\n",
    "        while candidate in existing:\n",
    "            suffix = f\"_{counter}\"\n",
    "            trimmed = safe[: 31 - len(suffix)] or \"Sheet\"\n",
    "            candidate = f\"{trimmed}{suffix}\"\n",
    "            counter += 1\n",
    "        existing.add(candidate)\n",
    "        return candidate\n",
    "\n",
    "    engine = pick_engine()\n",
    "    used_names = set()\n",
    "    with pd.ExcelWriter(path, engine=engine) as writer:\n",
    "        for sheet_name, frame in serialisable:\n",
    "            name = normalise_sheet_name(str(sheet_name), used_names)\n",
    "            frame.to_excel(writer, sheet_name=name, index=True)\n",
    "\n",
    "    print(\n",
    "        f\"Berhasil mengekspor {len(serialisable)} sheet ke {path} (engine: {engine})\"\n",
    "    )\n",
    "    return path\n",
    "export_dir = PROJECT_ROOT / \"outputs\" / \"result-test\"\n",
    "export_path = export_dir / \"strategy_comparison_tf1h.xlsx\"\n",
    "\n",
    "export_payload = {\n",
    "    \"comparison_metrics\": comparison,\n",
    "    \"strategy_overview\": strategy_overview,\n",
    "    \"exposure_summary\": exposure,\n",
    "}\n",
    "\n",
    "for label, output in results.items():\n",
    "    export_payload[f\"{label}_trade_summary\"] = pd.DataFrame([output.trade_summary])\n",
    "    export_payload[f\"{label}_trades\"] = output.trades\n",
    "    export_payload[f\"{label}_equity\"] = output.results\n",
    "\n",
    "\n",
    "for ml_label, ml_predictions in ml_predictions_map.items():\n",
    "    export_payload[f\"{ml_label}_predictions\"] = ml_predictions\n",
    "\n",
    "for ml_label, ml_equity in ml_equity_map.items():\n",
    "    export_payload[f\"{ml_label}_equity\"] = ml_equity\n",
    "\n",
    "for ml_label, ml_trade_summary in ml_trade_summary_map.items():\n",
    "    export_payload[f\"{ml_label}_trade_summary\"] = pd.DataFrame([ml_trade_summary])\n",
    "\n",
    "for ml_label, ml_trades in ml_trades_map.items():\n",
    "    export_payload[f\"{ml_label}_trades\"] = ml_trades\n",
    "\n",
    "export_tables_to_excel(export_payload, export_path)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
